
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="google-site-verification" content="sBAfGubPxv1ol5QEVGgOJ4ggp5spK-zFFXpK-Pd2xZM" />
    <meta name="naver-site-verification" content="a37ea649edf26e70c3de94f9cb034f9d6e11de3f" />
    <meta name="generator" content="Yun Blog">
    <title>JPA N+1 발생원인과 해결방법 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"\n해당 코드는 Github를 확인할 수 있습니다.\n\nJPA를 사용하다면 보면 N+1문제를 많이 만나게 됩니다. 그에 따른 발생 원인과 해결법을 정리해 보았습니다.\nERD#\n12345678910111213141516171819@Entity@Table(name = &quot;member&quot;)class Member private constructor() &#123;    ...    @OneToMany(mappedBy = &quot;member&quot;, fetch = FetchType.LAZY)    var orders: Set&lt;Order&gt; = emptySet()        private set&#125;@Entity@Table(name = &quot;orders&quot;)class Order private constructor() &#123;    ...    @ManyToOne(fetch = FetchType.LAZY)    @JoinColumn(name = &quot;member_id&quot;, nullable = false, updatable = false)    lateinit var member: Member        private set\n\n위 엔티티처럼 멤버 &lt;-&gt; 주문 관계를 기준으로 설명드리겠습니다.\n발생 케이스#즉시로딩 N+1#12345@Testinternal fun `지연 로딩 n+1`() &#123;    // fetch = FetchType.EAGER 의 경우    val members = memberRepository.findAll()&#125;\n\n\nfetch = FetchType.EAGER 전략을 즉시 로딩으로 가져가면 N+1 문제가 발생합니다.\n지연로딩과 N+1#12345@Testinternal fun `지연 로딩 n+1`() &#123;    // fetch = FetchType.LAZY 의 경우    val members = memberRepository.findAll()&#125;\n\nfetch = FetchType.LAZY 설정으로 LAZY 로딩을 하면 N+1 문제는 발생하지 않습니다.\n12345678@Testinternal fun `지연로딩인 n+1`() &#123;    val members = memberRepository.findAll()    // 회원 한명에 대한 조회는 문제가 없다    val firstMember = members[0]    println(firstMember.orders.size)&#125;\n\n위처럼 한 명의 member를 조회했기 때문에 해당 memeber의 order를 위 와 같은 SQL로 조회합니다. 하지만 아래 코드처럼 모든 Member에 대해서 주문을 조회하는 경우 N+1문제가 발생합니다.\n12345678910111213@Testinternal fun `지연로딩인 n+1`() &#123;    val members = memberRepository.findAll()    // 회원 한명에 대한 조회는 문제가 없다    val firstMember = members[0]    println(&quot;order size : $&#123;firstMember.orders.size&#125;&quot;)    // 조회한 모든 회원에 대해서 조회하는 경우 문제 발생    for(member in members)&#123;        println(&quot;order size: $&#123;member.orders.size&#125;&quot;)    &#125;&#125;\n\n결국 지연 로딩에서도 N+1 문제는 발생합니다.\n원인#\nfindById() 같은 경우에는 엔티티를 영속성 컨텍스트에서 먼저 찾고 영속성 컨텍스트에 없는 경우에 데이터베이스에 찾는 반면 JPQL은 항상 데이터베이스에 SQL을 실행해서 결과를 조회합니다. 그리고 아래와 같은 작업을 진행하게 됩니다.\n\nJPQL을 호출하면 데이터베이스에 우선 적으로 조회한다.\n조회한 값을 영속성 컨텍스트에 저장한다.\n영속성 컨텍스트에 조회할 때 이미 존재하는 데이터가 있다면(같은 영속성 컨텍스트에서 이미 조회한 유저가 있는 경우) 데이터를 버린다.\n\nJPQL의 동작 순서는 위와 같고 그렇다면 왜 N+1이 발생하는 것일까요? JPQL을 실행하면 JPA는 이것을 분석해서 SQL을 생성합니다. JPQL 입장에서는 즉시 로딩, 지연 로딩과 같은 글로벌 페치 전략을 무시하고 JPQL만 사용해서 SQL을 생성합니다. \n즉시 로딩인 경우#1val members = memberRepository.findAll()\nJPQL에서 동작한 쿼리를 통해서 members에 데이터가 바인딩 됩니다. 그 이후 JPA에서는 글로벌 페치 전략(즉시 로딩)을 받아들여 해당 member의 연관관계인 order에 대해서 추가적인 레이지 로딩이 진행되어 N+1을 발생시킵니다.\n지연 로딩인 경우#1val members = memberRepository.findAll()\nJPQL에서 동작한 쿼리를 통해서 members에 데이터가 바인딩 됩니다. JPA가 글로벌 페치 전략을 받아들이지만 지연 로딩이기 때문에 추가적인 SQL을 발생시키지 않습니다. 하지만 위에서 본 예제처럼 레이지 로딩으로 추가적인 작업을 진행하게 되면 결국 N+1 문제가 발생하게 됩니다.\n해결 방법#Batch SIZE#12345678910@Entity@Table(name = &quot;member&quot;)class Member private constructor() &#123;    ...    @BatchSize(size = 5) // Batch size를 지정한다    @OneToMany(mappedBy = &quot;member&quot;, fetch = FetchType.EAGER) // 즉시 로딩으로 설정    var orders: List&lt;Order&gt; = emptyList()        private set&#125;\n\n\n@BatchSize(size = 5) 에노 테이션을 통해서 설정한 size 만큼 데이터를 미리 로딩 합니다. 즉 연관된 엔티티를 조회할 때 size 만큼 where in 쿼리를 통해서 조회하게 되고 size를 넘어가게 되면 추가로 where in 쿼리를 진행합니다. 하지만 글로벌 페치 전략을 변경해야 하며, 정해진 Batch size 만큼 조회되는 단점도 있습니다.\n페치 조인 사용#1234567interface MemberRepository : JpaRepository&lt;Member, Long&gt; &#123;        @Query(            &quot;select m from Member m left join fetch m.orders&quot;    )    fun findAllWithFetch(): List&lt;Member&gt;&#125;\n\n123456789@Testinternal fun `페치 조인 사용`() &#123;    val members = memberRepository.findAllWithFetch()    // 조회한 모든 회원에 대해서 조회하는 경우에도 N+1 문제가 발생하지 않음    for (member in members) &#123;        println(&quot;order size: $&#123;member.orders.size&#125;&quot;)    &#125;&#125;\n\n가장 많이 사용하는 방법인 fetch을 통해서 조인 쿼리를 진행하는 것입니다. fetch 키워드를 사용하게 되면 연관된 엔티티나 컬렉션을 한 번에 같이 조회할 수 있습니다. 즉 페치 조인을 사용하게 되면 연관된 엔티티는 프록시가 아닌 실제 엔티티를 조회하게 되므로 연관관계 객체까지 한 번의 쿼리로 가져올 수 있습니다.\n\n위 로그를 보면 SQL을 통해서 한 번에 데이터를 가져옵니다. Order Size: 10을 보면 N+1이 발생하지 않고 있습니다. 그렇다면 fetch 키워드를 제거하면 어떻게 될까요?\n페치 조인과 일반 조인 차이#1234567interface MemberRepository : JpaRepository&lt;Member, Long&gt; &#123;    @Query(            &quot;select m from Member m join m.orders&quot;    )    fun findAllWithFetch(): List&lt;Member&gt;&#125;\n\n123456789@Testinternal fun `페치 조인 키워드 제거`() &#123;    val members = memberRepository.findAllWithFetch() // 페치 타입 Lazy 경우    // 페치 조인하지 않은 상태에서는 N+1 문제 발생    for (member in members) &#123;        println(&quot;order size: $&#123;member.orders.size&#125;&quot;)    &#125;&#125;\n\n\n출력되는 SQL을 보면 조인을 통해서 연관관계 컬렉션까지 함께 조회되는 것으로 생각할 수 있습니다. 하지만 JPQL은 결과를 반환할 때 연관관계까지 고려하지 않고 select 절에 지정한 엔티티만 조회하게 됩니다. 따라서 컬렉션은 초기화하지 않은 컬렉션 레퍼를 반환하게 되고 컬렉션이 없기 때문에 Lazy 로딩이 발생하게 되고 결과적으로 N+1 문제가 발생하게 됩니다.\n페치 조인의 한계#그렇다면 Fetch 조인이 만능일까요? 아쉽지만 Fetch 조인은 몇 가지의 한계가 있습니다.\n컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.#1234567interface MemberRepository : JpaRepository&lt;Member, Long&gt; &#123;    @Query(            value = &quot;select m from Member m left join fetch m.orders&quot;,            countQuery = &quot;select count(m) from Member m&quot;    )    fun findAllWithFetchPaging(pageable: Pageable): Page&lt;Member&gt;&#125;\n\n1234567891011@Testinternal fun `컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다`() &#123;    val page = PageRequest.of(0, 10)    val members = memberRepository.findAllWithFetchPaging(page)    // 조회한 모든 회원에 대해서 조회하는 경우에도 N+1 문제가 발생하지 않음    for (member in members) &#123;        println(&quot;order size: $&#123;member.orders.size&#125;&quot;)    &#125;&#125;\n\n이전에 Paging 처리 Fetch Join 적용 시 limit 동작하지 않는 이슈에서도 다룬 적 있습니다. 해당 쿼리에서는 limit offset 관련된 쿼리문이 없습니다. 하이버네이트에서 컬렉션을 페치 조인하고 페이지 API를 사용하면 메모리에서 페이징 처리를 진행합니다. 즉 데이터베이스에서는 FULL Scan 한 이후 모든 데이터를 메모리에 올린 이후 limit에 맞게 데이터를 만들게 됩니다. 우선 데이터베이스에 Full Sacn 하는 것도 문제지만 그것을 메모리에 올리기 때문에 메모리를 심하게 잡아먹게 됩니다. 컬렉션이 아닌 단일 값 연관 필드의 경우에는 페치 조인을 사용해도 페이징 API를 사용할 수 있습니다.\n둘 이상 컬렉션을 페치할 수 없다.#\n위 ERD 처럼 member가 orders, copons를 갖는 테이블 구조인 경우\n12345678910111213@Entity@Table(name = &quot;member&quot;)class Member private constructor() &#123;    ...    @OneToMany(mappedBy = &quot;member&quot;, fetch = FetchType.LAZY)    var orders: List&lt;Order&gt; = emptyList()        private set    @OneToMany(mappedBy = &quot;member&quot;, fetch = FetchType.LAZY) // 새로운 컬렉션 쿠폰 추가    var coupons: List&lt;Coupon&gt; = emptyList()        private set&#125;\n\n12345@Query(        value = &quot;select m from Member m left join fetch m.orders left join fetch m.coupons&quot;,        countQuery = &quot;select count(m) from Member m&quot;    )fun findAllWithFetchPaging2(pageable: Pageable): Page&lt;Member&gt;\n\n12345678910@Testinternal fun `둘 이상 컬렉션을 페치할 수 없다`() &#123;    val page = PageRequest.of(0, 10)    val members = memberRepository.findAllWithFetchPaging2(page)    // 조회한 모든 회원에 대해서 조회하는 경우에도 N+1 문제가 발생하지 않음    for (member in members) &#123;        println(&quot;order size: $&#123;member.orders.size&#125;&quot;)    &#125;&#125;\n\n컬렉션의 카테시안 곱이 만들어지므로 하이버네이트는 주의해야 합니다. 하이버네이트는 annot simultaneously fetch multiple bag 예외가 발생하게 됩니다. 가장 쉬운 해결 방법으로는 자료형을 List -&gt; Set으로 변경하는 것입니다.\n12345678910111213@Entity@Table(name = &quot;member&quot;)class Member private constructor() &#123;    ...    @OneToMany(mappedBy = &quot;member&quot;, fetch = FetchType.LAZY)    var orders: Set&lt;Order&gt; = emptySet()        private set    @OneToMany(mappedBy = &quot;member&quot;, fetch = FetchType.LAZY)    var coupons: Set&lt;Coupon&gt; = emptySet()        private set&#125;\n\n아래 코드처럼 변경하고 테스트 코드를 다시 실행하면 아래와 같은 결과를 확인할 수 있습니다.\n\n하지만 이 방법도 권장 드리지 않습니다. 특정 에러를 해결하기 위해서 자료형을 바꾸는 것 자체가 좋은 해결법이 아니며 도메인 레이어는 아주 중요한 레이어이기 때문에 더 권장 드리지 않습니다.\n참고#\n자바 ORM 표준 JPA 프로그래밍\n\n","dateCreated":"2019-10-27T18:16:27+09:00","dateModified":"2025-01-31T20:24:39+09:00","datePublished":"2019-10-27T18:16:27+09:00","description":"JPA를 사용하다면 보면 N+1문제를 많이 만나게 됩니다. 그에 따른 발생 원인과 해결법을 정리해 보았습니다.","headline":"JPA N+1 발생원인과 해결방법","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/jpa-nplus-1/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/jpa-nplus-1/","keywords":"JPA, ORM"}</script>
    <meta name="description" content="JPA를 사용하다면 보면 N+1문제를 많이 만나게 됩니다. 그에 따른 발생 원인과 해결법을 정리해 보았습니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="JPA N+1 발생원인과 해결방법">
<meta property="og:url" content="https://cheese10yun.github.io/jpa-nplus-1/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="JPA를 사용하다면 보면 N+1문제를 많이 만나게 됩니다. 그에 따른 발생 원인과 해결법을 정리해 보았습니다.">
<meta property="og:locale" content="ko_KR">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-erd.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lazy-3.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lay-1.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lazy-2.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lazy-3.png">
<meta property="og:image" content="https://github.com/cheese10yun/TIL/blob/master/assets/jpa-n+1.png?raw=true">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-batch-size.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-join.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-join-2.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-paging.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-erd2.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-muliple.png">
<meta property="og:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-muliple-2.png">
<meta property="article:published_time" content="2019-10-27T09:16:27.000Z">
<meta property="article:modified_time" content="2025-01-31T11:24:39.793Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="JPA">
<meta property="article:tag" content="ORM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-erd.png">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            JPA N+1 발생원인과 해결방법
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-10-27T18:16:27+09:00">
	
		    2019/10/27
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>해당 코드는 <a target="_blank" rel="noopener" href="https://github.com/cheese10yun/blog-sample/tree/master/jpa-n-plus-1">Github</a>를 확인할 수 있습니다.</p>
</blockquote>
<p>JPA를 사용하다면 보면 N+1문제를 많이 만나게 됩니다. 그에 따른 발생 원인과 해결법을 정리해 보았습니다.</p>
<h2><span id="erd">ERD</span><a href="#erd" class="header-anchor">#</a></h2><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-erd.png"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="string">&quot;member&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="string">&quot;member&quot;</span>, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">var</span> orders: Set&lt;Order&gt; = emptySet()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="string">&quot;orders&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = <span class="string">&quot;member_id&quot;</span>, nullable = false, updatable = false)</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> member: Member</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br></pre></td></tr></table></figure>

<p>위 엔티티처럼 멤버 &lt;-&gt; 주문 관계를 기준으로 설명드리겠습니다.</p>
<h2><span id="balsaeng-keiseu">발생 케이스</span><a href="#balsaeng-keiseu" class="header-anchor">#</a></h2><h3><span id="jeugsiroding-n-1">즉시로딩 N+1</span><a href="#jeugsiroding-n-1" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `지연 로딩 n+1`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// fetch = FetchType.EAGER 의 경우</span></span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lazy-3.png"></p>
<p><strong><code>fetch = FetchType.EAGER</code> 전략을 즉시 로딩으로 가져가면 N+1 문제가 발생합니다.</strong></p>
<h3><span id="jiyeonrodinggwa-n-1">지연로딩과 N+1</span><a href="#jiyeonrodinggwa-n-1" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `지연 로딩 n+1`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// fetch = FetchType.LAZY 의 경우</span></span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lay-1.png"></p>
<p><code>fetch = FetchType.LAZY</code> 설정으로 LAZY 로딩을 하면 N+1 문제는 발생하지 않습니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `지연로딩인 n+1`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 회원 한명에 대한 조회는 문제가 없다</span></span><br><span class="line">    <span class="keyword">val</span> firstMember = members[<span class="number">0</span>]</span><br><span class="line">    println(firstMember.orders.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lazy-2.png"></p>
<p>위처럼 한 명의 member를 조회했기 때문에 해당 memeber의 order를 위 와 같은 SQL로 조회합니다. <strong>하지만 아래 코드처럼 모든 Member에 대해서 주문을 조회하는 경우 N+1문제가 발생합니다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `지연로딩인 n+1`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAll()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 회원 한명에 대한 조회는 문제가 없다</span></span><br><span class="line">    <span class="keyword">val</span> firstMember = members[<span class="number">0</span>]</span><br><span class="line">    println(<span class="string">&quot;order size : <span class="subst">$&#123;firstMember.orders.size&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조회한 모든 회원에 대해서 조회하는 경우 문제 발생</span></span><br><span class="line">    <span class="keyword">for</span>(member <span class="keyword">in</span> members)&#123;</span><br><span class="line">        println(<span class="string">&quot;order size: <span class="subst">$&#123;member.orders.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-lazy-3.png"></p>
<p><strong>결국 지연 로딩에서도 N+1 문제는 발생합니다.</strong></p>
<h2><span id="weonin">원인</span><a href="#weonin" class="header-anchor">#</a></h2><p><img src="https://github.com/cheese10yun/TIL/blob/master/assets/jpa-n+1.png?raw=true"></p>
<p><code>findById()</code> 같은 경우에는 엔티티를 영속성 컨텍스트에서 먼저 찾고 영속성 컨텍스트에 없는 경우에 데이터베이스에 찾는 <strong>반면 JPQL은 항상 데이터베이스에 SQL을 실행해서 결과를 조회합니다.</strong> 그리고 아래와 같은 작업을 진행하게 됩니다.</p>
<ol>
<li><strong>JPQL을 호출하면 데이터베이스에 우선 적으로 조회한다.</strong></li>
<li>조회한 값을 영속성 컨텍스트에 저장한다.</li>
<li>영속성 컨텍스트에 조회할 <strong>때 이미 존재하는 데이터가 있다면(같은 영속성 컨텍스트에서 이미 조회한 유저가 있는 경우) 데이터를 버린다.</strong></li>
</ol>
<p><strong>JPQL의 동작 순서는 위와 같고 그렇다면 왜 N+1이 발생하는 것일까요? JPQL을 실행하면 JPA는 이것을 분석해서 SQL을 생성합니다. JPQL 입장에서는 즉시 로딩, 지연 로딩과 같은 글로벌 페치 전략을 무시하고 JPQL만 사용해서 SQL을 생성합니다.</strong> </p>
<h3><span id="jeugsi-rodingin-gyeongu">즉시 로딩인 경우</span><a href="#jeugsi-rodingin-gyeongu" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> members = memberRepository.findAll()</span><br></pre></td></tr></table></figure>
<p>JPQL에서 동작한 쿼리를 통해서 members에 데이터가 바인딩 됩니다. <strong>그 이후 JPA에서는 글로벌 페치 전략(즉시 로딩)을 받아들여 해당 member의 연관관계인 order에 대해서 추가적인 레이지 로딩이 진행되어 N+1을 발생시킵니다.</strong></p>
<h3><span id="jiyeon-rodingin-gyeongu">지연 로딩인 경우</span><a href="#jiyeon-rodingin-gyeongu" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> members = memberRepository.findAll()</span><br></pre></td></tr></table></figure>
<p>JPQL에서 동작한 쿼리를 통해서 members에 데이터가 바인딩 됩니다. <strong>JPA가 글로벌 페치 전략을 받아들이지만 지연 로딩이기 때문에 추가적인 SQL을 발생시키지 않습니다.</strong> 하지만 위에서 본 예제처럼 레이지 로딩으로 추가적인 작업을 진행하게 되면 결국 N+1 문제가 발생하게 됩니다.</p>
<h2><span id="haegyeol-bangbeob">해결 방법</span><a href="#haegyeol-bangbeob" class="header-anchor">#</a></h2><h3><span id="batch-size">Batch SIZE</span><a href="#batch-size" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="string">&quot;member&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BatchSize(size = 5)</span> <span class="comment">// Batch size를 지정한다</span></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="string">&quot;member&quot;</span>, fetch = FetchType.EAGER)</span> <span class="comment">// 즉시 로딩으로 설정</span></span><br><span class="line">    <span class="keyword">var</span> orders: List&lt;Order&gt; = emptyList()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-batch-size.png"></p>
<p><code>@BatchSize(size = 5)</code> 에노 테이션을 통해서 설정한 size 만큼 데이터를 미리 로딩 합니다. 즉 연관된 엔티티를 조회할 때 size 만큼 <code>where in</code> 쿼리를 통해서 조회하게 되고 size를 넘어가게 되면 추가로 <code>where in</code> 쿼리를 진행합니다. 하지만 <strong>글로벌 페치 전략을 변경해야 하며, 정해진 Batch size 만큼 조회되는 단점도 있습니다.</strong></p>
<h3><span id="peci-join-sayong">페치 조인 사용</span><a href="#peci-join-sayong" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberRepository</span> : <span class="type">JpaRepository</span>&lt;<span class="type">Member, Long</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;select m from Member m left join fetch m.orders&quot;</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findAllWithFetch</span><span class="params">()</span></span>: List&lt;Member&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `페치 조인 사용`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAllWithFetch()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조회한 모든 회원에 대해서 조회하는 경우에도 N+1 문제가 발생하지 않음</span></span><br><span class="line">    <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">        println(<span class="string">&quot;order size: <span class="subst">$&#123;member.orders.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>가장 많이 사용하는 방법인 <code>fetch</code>을 통해서 조인 쿼리를 진행하는 것입니다. <code>fetch</code> 키워드를 사용하게 되면 연관된 엔티티나 컬렉션을 한 번에 같이 조회할 수 있습니다. <strong>즉 페치 조인을 사용하게 되면 연관된 엔티티는 프록시가 아닌 실제 엔티티를 조회하게 되므로 연관관계 객체까지 한 번의 쿼리로 가져올 수 있습니다.</strong></p>
<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-join.png"></p>
<p>위 로그를 보면 SQL을 통해서 한 번에 데이터를 가져옵니다. <strong><code>Order Size: 10</code>을 보면 N+1이 발생하지 않고 있습니다.</strong> 그렇다면 <code>fetch</code> 키워드를 제거하면 어떻게 될까요?</p>
<h4><span id="peci-joingwa-ilban-join-cai">페치 조인과 일반 조인 차이</span><a href="#peci-joingwa-ilban-join-cai" class="header-anchor">#</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberRepository</span> : <span class="type">JpaRepository</span>&lt;<span class="type">Member, Long</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;select m from Member m join m.orders&quot;</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findAllWithFetch</span><span class="params">()</span></span>: List&lt;Member&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `페치 조인 키워드 제거`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAllWithFetch() <span class="comment">// 페치 타입 Lazy 경우</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 페치 조인하지 않은 상태에서는 N+1 문제 발생</span></span><br><span class="line">    <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">        println(<span class="string">&quot;order size: <span class="subst">$&#123;member.orders.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-join-2.png"></p>
<p>출력되는 SQL을 보면 조인을 통해서 연관관계 컬렉션까지 함께 조회되는 것으로 생각할 수 있습니다. <strong>하지만 JPQL은 결과를 반환할 때 연관관계까지 고려하지 않고 select 절에 지정한 엔티티만 조회하게 됩니다.</strong> 따라서 컬렉션은 초기화하지 않은 컬렉션 레퍼를 반환하게 되고 컬렉션이 없기 때문에 Lazy 로딩이 발생하게 되고 <strong>결과적으로 N+1 문제가 발생하게 됩니다.</strong></p>
<h2><span id="peci-joinyi-hangye">페치 조인의 한계</span><a href="#peci-joinyi-hangye" class="header-anchor">#</a></h2><p>그렇다면 Fetch 조인이 만능일까요? 아쉽지만 Fetch 조인은 몇 가지의 한계가 있습니다.</p>
<h3><span id="keolregsyeoneul-peci-joinhamyeon-peijing-apireul-sayonghal-su-eobsda">컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.</span><a href="#keolregsyeoneul-peci-joinhamyeon-peijing-apireul-sayonghal-su-eobsda" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MemberRepository</span> : <span class="type">JpaRepository</span>&lt;<span class="type">Member, Long</span>&gt; &#123;</span><br><span class="line">    <span class="meta">@Query(</span></span><br><span class="line"><span class="meta">            value = <span class="string">&quot;select m from Member m left join fetch m.orders&quot;</span>,</span></span><br><span class="line"><span class="meta">            countQuery = <span class="string">&quot;select count(m) from Member m&quot;</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">findAllWithFetchPaging</span><span class="params">(pageable: <span class="type">Pageable</span>)</span></span>: Page&lt;Member&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> page = PageRequest.of(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAllWithFetchPaging(page)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조회한 모든 회원에 대해서 조회하는 경우에도 N+1 문제가 발생하지 않음</span></span><br><span class="line">    <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">        println(<span class="string">&quot;order size: <span class="subst">$&#123;member.orders.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-paging.png"></p>
<p>이전에 <a target="_blank" rel="noopener" href="https://github.com/cheese10yun/blog-sample/tree/master/jpa-fetch-join">Paging 처리 Fetch Join 적용 시 limit 동작하지 않는 이슈</a>에서도 다룬 적 있습니다. 해당 쿼리에서는 limit offset 관련된 쿼리문이 없습니다. <strong>하이버네이트에서 컬렉션을 페치 조인하고 페이지 API를 사용하면 메모리에서 페이징 처리를 진행합니다.</strong> 즉 데이터베이스에서는 FULL Scan 한 이후 모든 데이터를 메모리에 올린 이후 limit에 맞게 데이터를 만들게 됩니다. 우선 데이터베이스에 Full Sacn 하는 것도 문제지만 그것을 메모리에 올리기 때문에 메모리를 심하게 잡아먹게 됩니다. <strong>컬렉션이 아닌 단일 값 연관 필드의 경우에는 페치 조인을 사용해도 페이징 API를 사용할 수 있습니다.</strong></p>
<h3><span id="dul-isang-keolregsyeoneul-pecihal-su-eobsda">둘 이상 컬렉션을 페치할 수 없다.</span><a href="#dul-isang-keolregsyeoneul-pecihal-su-eobsda" class="header-anchor">#</a></h3><p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-erd2.png"></p>
<p>위 ERD 처럼 member가 orders, copons를 갖는 테이블 구조인 경우</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="string">&quot;member&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="string">&quot;member&quot;</span>, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">var</span> orders: List&lt;Order&gt; = emptyList()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="string">&quot;member&quot;</span>, fetch = FetchType.LAZY)</span> <span class="comment">// 새로운 컬렉션 쿠폰 추가</span></span><br><span class="line">    <span class="keyword">var</span> coupons: List&lt;Coupon&gt; = emptyList()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(</span></span><br><span class="line"><span class="meta">        value = <span class="string">&quot;select m from Member m left join fetch m.orders left join fetch m.coupons&quot;</span>,</span></span><br><span class="line"><span class="meta">        countQuery = <span class="string">&quot;select count(m) from Member m&quot;</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findAllWithFetchPaging2</span><span class="params">(pageable: <span class="type">Pageable</span>)</span></span>: Page&lt;Member&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> `둘 이상 컬렉션을 페치할 수 없다`<span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> page = PageRequest.of(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">val</span> members = memberRepository.findAllWithFetchPaging2(page)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조회한 모든 회원에 대해서 조회하는 경우에도 N+1 문제가 발생하지 않음</span></span><br><span class="line">    <span class="keyword">for</span> (member <span class="keyword">in</span> members) &#123;</span><br><span class="line">        println(<span class="string">&quot;order size: <span class="subst">$&#123;member.orders.size&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-muliple.png"></p>
<p>컬렉션의 카테시안 곱이 만들어지므로 하이버네이트는 주의해야 합니다. 하이버네이트는 <code>annot simultaneously fetch multiple bag</code> 예외가 발생하게 됩니다. 가장 쉬운 해결 방법으로는 자료형을 List -&gt; Set으로 변경하는 것입니다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = <span class="string">&quot;member&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> <span class="keyword">private</span> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="string">&quot;member&quot;</span>, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">var</span> orders: Set&lt;Order&gt; = emptySet()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(mappedBy = <span class="string">&quot;member&quot;</span>, fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">var</span> coupons: Set&lt;Coupon&gt; = emptySet()</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>아래 코드처럼 변경하고 테스트 코드를 다시 실행하면 아래와 같은 결과를 확인할 수 있습니다.</p>
<p><img src="https://github.com/cheese10yun/blog-sample/raw/master/jpa-n-plus-1/images/jpa-fetch-muliple-2.png"></p>
<p><strong>하지만 이 방법도 권장 드리지 않습니다. 특정 에러를 해결하기 위해서 자료형을 바꾸는 것 자체가 좋은 해결법이 아니며 도메인 레이어는 아주 중요한 레이어이기 때문에 더 권장 드리지 않습니다.</strong></p>
<h2><span id="camgo">참고</span><a href="#camgo" class="header-anchor">#</a></h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.acornpub.co.kr/book/jpa-programmig">자바 ORM 표준 JPA 프로그래밍</a></li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/JPA/" rel="tag">JPA</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/ORM/" rel="tag">ORM</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/junit5-in-spring/"
                    data-tooltip="Junit5 with Spring boot"
                    aria-label="이전: Junit5 with Spring boot"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/intellij-execute-gradle-task/"
                    data-tooltip="인텔리제이 Execute Gradle task로 Gradle를 쉽게 사용하자"
                    aria-label="다음: 인텔리제이 Execute Gradle task로 Gradle를 쉽게 사용하자"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/jpa-nplus-1/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/jpa-nplus-1/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        

                
                    <!--  utteranc comment -->

<script src="https://utteranc.es/client.js"
        repo="cheese10yun/blog-comment"
        issue-term="title"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

                

            
        
    </div>
</article>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2026 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/junit5-in-spring/"
                    data-tooltip="Junit5 with Spring boot"
                    aria-label="이전: Junit5 with Spring boot"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/intellij-execute-gradle-task/"
                    data-tooltip="인텔리제이 Execute Gradle task로 Gradle를 쉽게 사용하자"
                    aria-label="다음: 인텔리제이 Execute Gradle task로 Gradle를 쉽게 사용하자"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/jpa-nplus-1/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/jpa-nplus-1/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/jpa-nplus-1/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/jpa-nplus-1/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
