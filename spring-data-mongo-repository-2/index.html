
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="google-site-verification" content="sBAfGubPxv1ol5QEVGgOJ4ggp5spK-zFFXpK-Pd2xZM" />
    <meta name="naver-site-verification" content="a37ea649edf26e70c3de94f9cb034f9d6e11de3f" />
    <meta name="generator" content="Yun Blog">
    <title>Spring Data MongoDB Repository 확장 - Aggregation 기반 페이징 처리 - Yun Blog</title>
    <meta name="author" content="Yun">
    
        <meta name="keywords" content="Node,Spring,Spring Boot,Spring Batch,Kotlin,기술 블로그,JPA,Mongo,MySQL,OOP,">
    
    
    
        
            <link rel="alternate" type="application/rss+xml" title="RSS" href="/rss2.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg"},"articleBody":"기존 Spring Data MongoDB Repository 확장 포스팅에서는 복잡한 쿼리 로직을 분리하여 상위 레벨에서는 구현 디테일을 신경 쓰지 않고, 데이터 접근 로직을 단순화할 수 있는 방법을 다루었습니다.  특히, Slice 기반 및 Page 기반의 페이징 처리를 적용하여 다음과 같은 장점을 얻을 수 있었습니다.\n\nPage 기반 페이징 처리:\n카운트 쿼리와 컨텐츠 쿼리를 병렬로 실행하여 성능 최적화\n\n\nSlice 기반 페이징 처리:\nhasNext 처리를 위임하여 반복적인 코드 없이 페이징을 처리\n\n\n\n그러나 이러한 방식은 단순히 도큐먼트 객체(T) 타입을 기준으로 설계되어, 복잡한 데이터 변환, 조인, 그룹화 등 다양한 데이터 처리 작업을 다루는 데 한계가 있었습니다. 특히, 프로젝션을 활용한 데이터 조회나 복잡한 쿼리는 Aggregation을 사용하여 해결해야 하기 때문에, Aggregation을 기반으로 하는 페이징 처리가 필요합니다.따라서, 이번 포스팅에서는 MongoTemplate을 기반으로 Aggregation을 활용한 페이징 처리 방법을 확장하여 이 문제를 해결하는 방법을 다루겠습니다.\n기존 Query 기반 Pagination과 Slice 처리#기존 applyPagination과 applySlice는 MongoTemplate을 활용하여 Query 기반으로 페이징을 처리하는 방식이었습니다.\nQuery 기반 Pagination 및 Slice 추상화#123456789101112131415161718protected fun &lt;S : T&gt; applyPagination(    pageable: Pageable,    contentQuery: (Query) -&gt; List&lt;S&gt;,    countQuery: (Query) -&gt; Long) = runBlocking &#123;    val content = async(Dispatchers.IO) &#123; contentQuery(Query().with(pageable)) &#125;    val totalCount = async(Dispatchers.IO) &#123; countQuery(Query()) &#125;    PageImpl(content.await(), pageable, totalCount.await())&#125;protected fun &lt;S : T&gt; applySlice(    pageable: Pageable,    contentQuery: (Query) -&gt; List&lt;S&gt;): Slice&lt;S&gt; &#123;    val content = contentQuery(Query().with(pageable))    val hasNext = content.size &gt;= pageable.pageSize    return SliceImpl(content, pageable, hasNext)&#125;\n\n사용 예시#기존 applyPagination과 applySlice를 활용하면 MongoTemplate을 사용하여 데이터를 간단하게 조회할 수 있습니다.\nSlice 조회#1234567891011121314151617181920override fun findSlice(    pageable: Pageable,    name: String?,    email: String?,    memberId: String?): Slice&lt;Member&gt; &#123;    val criteria = Criteria()        .apply &#123;            name?.let &#123; this.and(&quot;name&quot;).`is`(it) &#125;            email?.let &#123; this.and(&quot;email&quot;).`is`(it) &#125;            memberId?.let &#123; this.and(&quot;member_id&quot;).`is`(it) &#125;        &#125;    return applySlice(        pageable = pageable,        contentQuery = &#123;            mongoTemplate.find&lt;Member&gt;(it.addCriteria(criteria))        &#125;    )&#125;\n\nPage 조회#123456789101112131415161718override fun findPage(    pageable: Pageable,    name: String?,    email: String?,    memberId: String?): Page&lt;Member&gt; &#123;    val criteria = Criteria().apply &#123;        name?.let &#123; this.and(&quot;name&quot;).`is`(it) &#125;        email?.let &#123; this.and(&quot;email&quot;).`is`(it) &#125;        memberId?.let &#123; this.and(&quot;member_id&quot;).`is`(it) &#125;    &#125;    return applyPagination(        pageable = pageable,        contentQuery = &#123; mongoTemplate.find&lt;Member&gt;(it.addCriteria(criteria)) &#125;,        countQuery = &#123; mongoTemplate.count(it.addCriteria(criteria), documentClass) &#125;    )&#125;\n\n이 방식은 기본적인 도큐먼트(T) 조회에는 적합 하지만, 프로젝션을 활용한 데이터 조회에는 적용할 수 없는 한계가 있습니다.\nAggregation을 활용한 Projection 및 Pagination 확장#MongoDB에서는 Aggregation을 활용하여 특정 필드만 선택하거나, 데이터를 변환하는 프로젝션 외에도, 조인($lookup), 그룹화($group), 집계($count), 정렬($sort) 등 다양한 작업을 수행할 수 있습니다. 이러한 복잡한 데이터 처리 작업을 효율적으로 다루기 위해서는 Aggregation 기반의 페이징을 활용하는 것이 필요합니다. 이 방식은 기존 Query 기반 페이징 처리 방식에 비해 더 유연하고 강력한 쿼리 작성이 가능하며, 복잡한 데이터 변환 및 집계도 손쉽게 처리할 수 있습니다.\nAggregation 기반 Pagination 및 Slice 추상화 코드 설명#이 두 메서드는 MongoDB에서 Aggregation을 사용하여 페이징 처리 및 Slice 또는 Page 결과를 반환하는 기능을 제공합니다. 각 메서드는 Aggregation의 파이프라인을 동적으로 수정하고, skip과 limit을 추가하여 페이지네이션을 처리합니다.\napplyPaginationAggregation 메서드#12345678910111213141516171819202122232425262728protected fun &lt;S&gt; applyPaginationAggregation(    pageable: Pageable,    contentAggregation: Aggregation,    countAggregation: Aggregation,    contentQuery: (Aggregation) -&gt; AggregationResults&lt;S&gt;,    countQuery: (Aggregation) -&gt; AggregationResults&lt;MongoCount&gt;): PageImpl&lt;S&gt; = runBlocking &#123;    val skip = pageable.pageNumber * pageable.pageSize    val limit = pageable.pageSize    contentAggregation.pipeline.apply &#123;        this.add(Aggregation.skip(skip.toLong()))        this.add(Aggregation.limit(limit.toLong()))    &#125;    countAggregation.pipeline.apply &#123;        this.add(Aggregation.count().`as`(&quot;count&quot;))    &#125;    // Perform queries asynchronously    val contentDeferred = async(Dispatchers.IO) &#123; contentQuery(contentAggregation) &#125;    val countDeferred = async(Dispatchers.IO) &#123; countQuery(countAggregation) &#125;    val content = contentDeferred.await().mappedResults    val totalCount = countDeferred.await().uniqueMappedResult?.count ?: 0L    PageImpl(content, pageable, totalCount)&#125;\n\n설명#\ncontentAggregation:\n페이지네이션을 적용하기 위해 skip과 limit을 contentAggregation에 추가합니다. skip은 현재 페이지의 첫 번째 항목부터 건너뛸 수 있도록 하며, limit은 페이지당 보여줄 항목의 개수를 설정합니다.\n\n\ncountAggregation:\n카운트 쿼리를 처리하기 위해 countAggregation에서 $count를 사용하여 총 항목 수를 계산합니다. 이 단계에서는 skip과 limit을 적용하지 않고, 전체 항목 수만 계산합니다.\n\n\nrunBlocking:\n비동기 처리를 위해 runBlocking을 사용하여 contentQuery와 countQuery를 동시에 실행합니다. 이렇게 함으로써 페이징 처리 쿼리와 카운트 쿼리를 병렬로 실행하여 성능을 최적화합니다.\n\n\n쿼리 실행:\ncontentQuery(contentAggregation): contentAggregation을 기반으로 데이터를 조회합니다.\ncountQuery(countAggregation): countAggregation을 기반으로 총 개수를 조회합니다.\n\n\n응답 생성:\ncontent: 페이징된 결과 목록.\ntotalCount: 전체 항목 수.\nPageImpl 객체를 생성하여 결과를 반환합니다.\n\n\n\n사용된 MongoDB 쿼리#페이징 쿼리#12345678910111213141516171819db.members.aggregate([  &#123;    &quot;$match&quot;: &#123;      &quot;member_id&quot;: &quot;memberId&quot;    &#125;  &#125;,  &#123;    &quot;$project&quot;: &#123;      &quot;name&quot;: 1.0,      &quot;email&quot;: 1.0    &#125;  &#125;,  &#123;    &quot;$skip&quot;: 0.0  &#125;,  &#123;    &quot;$limit&quot;: 10.0  &#125;])\n\n카운트 쿼리#12345678910db.members.aggregate([  &#123;    &quot;$match&quot;: &#123;      &quot;member_id&quot;: &quot;memberId&quot;    &#125;  &#125;,  &#123;    &quot;$count&quot;: &quot;count&quot;  &#125;])\n\n이 두 쿼리는 각각 페이징 처리된 결과와 전체 항목 수를 계산하는 쿼리입니다. contentAggregation에서는 skip과 limit을 적용하여 데이터를 제한하고, countAggregation에서는 총 항목 수를 계산합니다.\napplySliceAggregation 메서드#12345678910111213141516protected fun &lt;S&gt; applySliceAggregation(    pageable: Pageable,    contentAggregation: Aggregation,    contentQuery: (Aggregation) -&gt; AggregationResults&lt;S&gt;): Slice&lt;S&gt; &#123;    val skip = pageable.pageNumber * pageable.pageSize    val limit = pageable.pageSize   contentAggregation.pipeline.apply &#123;        this.add(Aggregation.skip(skip.toLong()))        this.add(Aggregation.limit(limit.toLong()))    &#125;   val results = contentQuery(contentAggregation)    val content = results.mappedResults    val hasNext = content.size &gt;= pageable.pageSize    return SliceImpl(content, pageable, hasNext)&#125;\n\n설명:#\ncontentAggregation:\ncontentAggregation 는 사용자가 제공한 Aggregation 객체입니다. 이 객체에는 $match, $project와 같은 데이터 변환 및 필터링 로직이 포함됩니다.\ncontentAggregation에 skip 과 limit 을 추가하여 페이징을 처리합니다. 이를 통해 주어진 pageable에 맞게 데이터를 조회할 수 있습니다.\n\n\ncontentQuery:\ncontentAggregation을 기반으로 데이터를 조회하는 contentQuery 함수입니다. 이 함수는 Aggregation을 받아서 mongoTemplate.aggregate를 사용해 데이터를 가져옵니다.\n\n\n쿼리 실행:\ncontentQuery(contentAggregation)를 실행하여 페이징된 결과를 가져옵니다.\nskip과 limit을 포함한 contentAggregation을 전달하여 데이터를 필터링합니다.\n\n\n응답 생성:\ncontent: 페이징된 결과.\nhasNext: content의 크기가 pageable.pageSize보다 크거나 같으면, 더 많은 데이터가 있다는 뜻으로 hasNext를 설정합니다.\nSliceImpl 객체를 생성하여 결과를 반환합니다.\n\n\n\n사용된 MongoDB 쿼리#123456789101112131415161718192021db.members.aggregate([  &#123;    &quot;$match&quot;: &#123;      &quot;name&quot;: &quot;11-name&quot;,      &quot;email&quot;: &quot;11-asd@asd.com&quot;,      &quot;member_id&quot;: &quot;memberId&quot;    &#125;  &#125;,  &#123;    &quot;$project&quot;: &#123;      &quot;name&quot;: 1.0,      &quot;email&quot;: 1.0    &#125;  &#125;,  &#123;    &quot;$skip&quot;: 0.0  &#125;,  &#123;    &quot;$limit&quot;: 10.0  &#125;])\n\nAggregation 기반 Page 및 Slice 조회 예시#Slice 조회#1234567891011121314151617181920212223override fun findSliceAggregation(    pageable: Pageable,    name: String?,    email: String?,    memberId: String?): Slice&lt;MemberProjection&gt; &#123;    val match = Aggregation.match(        Criteria().apply &#123;            name?.let &#123; this.and(&quot;name&quot;).`is`(it) &#125;            email?.let &#123; this.and(&quot;email&quot;).`is`(it) &#125;            memberId?.let &#123; this.and(&quot;member_id&quot;).`is`(it) &#125;        &#125;    )    val projection = Aggregation.project()        .andInclude(&quot;name&quot;)        .andInclude(&quot;email&quot;)    return this.applySliceAggregation(        pageable = pageable,       contentAggregation = Aggregation.newAggregation(match, projection),        contentQuery = &#123; mongoTemplate.aggregate(it, Member.DOCUMENT_NAME, MemberProjection::class.java) &#125;    )&#125;\n\nPage 조회#1234567891011121314151617181920212223242526override fun findPageAggregation(    pageable: Pageable,    name: String?,    email: String?,    memberId: String?): Page&lt;MemberProjection&gt; &#123;    val match = Aggregation.match(        Criteria().apply &#123;            name?.let &#123; this.and(&quot;name&quot;).`is`(it) &#125;            email?.let &#123; this.and(&quot;email&quot;).`is`(it) &#125;            memberId?.let &#123; this.and(&quot;member_id&quot;).`is`(it) &#125;        &#125;    )    val projection = Aggregation.project()        .andInclude(&quot;name&quot;)        .andInclude(&quot;email&quot;)    return applyPaginationAggregation(        pageable = pageable,        contentAggregation = Aggregation.newAggregation(match, projection),        countAggregation = Aggregation.newAggregation(match),        contentQuery = &#123; mongoTemplate.aggregate(it, Member.DOCUMENT_NAME, MemberProjection::class.java) &#125;,        countQuery = &#123; mongoTemplate.aggregate(it, Member.DOCUMENT_NAME, MongoCount::class.java) &#125;    )&#125;\n\n결론#\n기존 Query 기반 페이징에서 T 타입 한계를 벗어나 Projection을 지원하도록 확장\nAggregation을 활용한 페이징 처리로 다양한 데이터 변환 및 성능 최적화 가능\n비동기(async) 처리로 성능 최적화하며, 코드 재사용성을 높임\n\n이제 Spring Data MongoDB에서 확장 가능한 Projection 기반 Pagination을 활용한 Repository를 구축할 수 있습니다.\n","dateCreated":"2025-01-30T10:00:00+09:00","dateModified":"2025-03-03T17:27:18+09:00","datePublished":"2025-01-30T10:00:00+09:00","description":"기존 Spring Data MongoDB Repository 확장 포스팅에서는 복잡한 쿼리 로직을 분리하여 상위 레벨에서는 구현 디테일을 신경 쓰지 않고, 데이터 접근 로직을 단순화할 수 있는 방법을 다루었습니다.","headline":"Spring Data MongoDB Repository 확장 - Aggregation 기반 페이징 처리","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheese10yun.github.io/spring-data-mongo-repository-2/"},"publisher":{"@type":"Organization","name":"Yun","sameAs":["https://github.com/cheese10yun"],"image":"yun-icon.jpg","logo":{"@type":"ImageObject","url":"yun-icon.jpg"}},"url":"https://cheese10yun.github.io/spring-data-mongo-repository-2/","keywords":"Mongo"}</script>
    <meta name="description" content="기존 Spring Data MongoDB Repository 확장 포스팅에서는 복잡한 쿼리 로직을 분리하여 상위 레벨에서는 구현 디테일을 신경 쓰지 않고, 데이터 접근 로직을 단순화할 수 있는 방법을 다루었습니다.">
<meta property="og:type" content="blog">
<meta property="og:title" content="Spring Data MongoDB Repository 확장 - Aggregation 기반 페이징 처리">
<meta property="og:url" content="https://cheese10yun.github.io/spring-data-mongo-repository-2/index.html">
<meta property="og:site_name" content="Yun Blog">
<meta property="og:description" content="기존 Spring Data MongoDB Repository 확장 포스팅에서는 복잡한 쿼리 로직을 분리하여 상위 레벨에서는 구현 디테일을 신경 쓰지 않고, 데이터 접근 로직을 단순화할 수 있는 방법을 다루었습니다.">
<meta property="og:locale" content="ko_KR">
<meta property="article:published_time" content="2025-01-30T01:00:00.000Z">
<meta property="article:modified_time" content="2025-03-03T08:27:18.605Z">
<meta property="article:author" content="Yun">
<meta property="article:tag" content="Mongo">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="https://cheese10yun.github.io/assets/images/yun-icon.jpg"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/all.css">

    
<link rel="stylesheet" href="/assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="/assets/css/thumbs.css">

    
<link rel="stylesheet" href="/assets/css/tranquilpeak.css">

    
    
<link rel="stylesheet" href="/assets/css/toc.css">

    
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90907312-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-90907312-1');
    </script>


    

    
        
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5813739623204880" crossorigin="anonymous"></script>
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="5">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Yun Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="5">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="저자에 대해 더 알아보기"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
                </a>
                <h4 class="sidebar-profile-name">Yun</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기술 블로그</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/cheese10yun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/rss2.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="5"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Spring Data MongoDB Repository 확장 - Aggregation 기반 페이징 처리
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2025-01-30T10:00:00+09:00">
	
		    2025/01/30
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p>기존 <a href="https://cheese10yun.github.io/spring-data-mongo-repository/">Spring Data MongoDB Repository 확장</a> 포스팅에서는 복잡한 쿼리 로직을 분리하여 상위 레벨에서는 구현 디테일을 신경 쓰지 않고, 데이터 접근 로직을 단순화할 수 있는 방법을 다루었습니다.  특히, <strong>Slice 기반 및 Page 기반의 페이징 처리</strong>를 적용하여 다음과 같은 장점을 얻을 수 있었습니다.</p>
<ul>
<li><strong>Page 기반 페이징 처리</strong>:<ul>
<li>카운트 쿼리와 컨텐츠 쿼리를 <strong>병렬로 실행</strong>하여 성능 최적화</li>
</ul>
</li>
<li><strong>Slice 기반 페이징 처리</strong>:<ul>
<li><code>hasNext</code> 처리를 위임하여 반복적인 코드 없이 페이징을 처리</li>
</ul>
</li>
</ul>
<p>그러나 이러한 방식은 <strong>단순히 도큐먼트 객체(<code>T</code>) 타입</strong>을 기준으로 설계되어, <strong>복잡한 데이터 변환</strong>, <strong>조인</strong>, <strong>그룹화</strong> 등 다양한 데이터 처리 작업을 다루는 데 한계가 있었습니다. 특히, <strong>프로젝션</strong>을 활용한 <strong>데이터 조회</strong>나 <strong>복잡한 쿼리</strong>는 <code>Aggregation</code>을 사용하여 해결해야 하기 때문에, <strong><code>Aggregation</code>을 기반으로 하는 페이징 처리</strong>가 필요합니다.<br>따라서, 이번 포스팅에서는 <strong><code>MongoTemplate</code>을 기반으로 <code>Aggregation</code>을 활용한 페이징 처리</strong> 방법을 확장하여 이 문제를 해결하는 방법을 다루겠습니다.</p>
<h2><span id="gijon-query-giban-paginationgwa-slice-ceori">기존 Query 기반 Pagination과 Slice 처리</span><a href="#gijon-query-giban-paginationgwa-slice-ceori" class="header-anchor">#</a></h2><p>기존 <code>applyPagination</code>과 <code>applySlice</code>는 <code>MongoTemplate</code>을 활용하여 <code>Query</code> 기반으로 페이징을 처리하는 방식이었습니다.</p>
<h3><span id="query-giban-pagination-mic-slice-cusanghwa">Query 기반 Pagination 및 Slice 추상화</span><a href="#query-giban-pagination-mic-slice-cusanghwa" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S : T&gt;</span> <span class="title">applyPagination</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentQuery: (<span class="type">Query</span>) -&gt; <span class="type">List</span>&lt;<span class="type">S</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    countQuery: (<span class="type">Query</span>) -&gt; <span class="type">Long</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> content = async(Dispatchers.IO) &#123; contentQuery(Query().with(pageable)) &#125;</span><br><span class="line">    <span class="keyword">val</span> totalCount = async(Dispatchers.IO) &#123; countQuery(Query()) &#125;</span><br><span class="line">    PageImpl(content.await(), pageable, totalCount.await())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S : T&gt;</span> <span class="title">applySlice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentQuery: (<span class="type">Query</span>) -&gt; <span class="type">List</span>&lt;<span class="type">S</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Slice&lt;S&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> content = contentQuery(Query().with(pageable))</span><br><span class="line">    <span class="keyword">val</span> hasNext = content.size &gt;= pageable.pageSize</span><br><span class="line">    <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="sayong-yesi">사용 예시</span><a href="#sayong-yesi" class="header-anchor">#</a></h3><p>기존 <code>applyPagination</code>과 <code>applySlice</code>를 활용하면 <code>MongoTemplate</code>을 사용하여 데이터를 간단하게 조회할 수 있습니다.</p>
<h4><span id="slice-johoe">Slice 조회</span><a href="#slice-johoe" class="header-anchor">#</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSlice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    email: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    memberId: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Slice&lt;Member&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> criteria = Criteria()</span><br><span class="line">        .apply &#123;</span><br><span class="line">            name?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            email?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;email&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            memberId?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;member_id&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> applySlice(</span><br><span class="line">        pageable = pageable,</span><br><span class="line">        contentQuery = &#123;</span><br><span class="line">            mongoTemplate.find&lt;Member&gt;(it.addCriteria(criteria))</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="page-johoe">Page 조회</span><a href="#page-johoe" class="header-anchor">#</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    email: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    memberId: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Page&lt;Member&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> criteria = Criteria().apply &#123;</span><br><span class="line">        name?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        email?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;email&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        memberId?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;member_id&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> applyPagination(</span><br><span class="line">        pageable = pageable,</span><br><span class="line">        contentQuery = &#123; mongoTemplate.find&lt;Member&gt;(it.addCriteria(criteria)) &#125;,</span><br><span class="line">        countQuery = &#123; mongoTemplate.count(it.addCriteria(criteria), documentClass) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 방식은 기본적인 도큐먼트(<code>T</code>) 조회에는 적합 하지만, 프로젝션을 활용한 데이터 조회에는 적용할 수 없는 한계가 있습니다.</p>
<h2><span id="aggregationeul-hwalyonghan-projection-mic-pagination-hwagjang">Aggregation을 활용한 Projection 및 Pagination 확장</span><a href="#aggregationeul-hwalyonghan-projection-mic-pagination-hwagjang" class="header-anchor">#</a></h2><p>MongoDB에서는 <strong>Aggregation</strong>을 활용하여 특정 필드만 선택하거나, 데이터를 변환하는 <strong>프로젝션</strong> 외에도, <strong>조인(<code>$lookup</code>)</strong>, <strong>그룹화(<code>$group</code>)</strong>, <strong>집계(<code>$count</code>)</strong>, <strong>정렬(<code>$sort</code>)</strong> 등 다양한 작업을 수행할 수 있습니다. 이러한 복잡한 데이터 처리 작업을 효율적으로 다루기 위해서는 <strong>Aggregation</strong> 기반의 페이징을 활용하는 것이 필요합니다. 이 방식은 기존 <code>Query</code> 기반 페이징 처리 방식에 비해 더 유연하고 강력한 쿼리 작성이 가능하며, 복잡한 데이터 변환 및 집계도 손쉽게 처리할 수 있습니다.</p>
<h3><span id="aggregation-giban-pagination-mic-slice-cusanghwa-kodeu-seolmyeong">Aggregation 기반 Pagination 및 Slice 추상화 코드 설명</span><a href="#aggregation-giban-pagination-mic-slice-cusanghwa-kodeu-seolmyeong" class="header-anchor">#</a></h3><p>이 두 메서드는 MongoDB에서 <strong>Aggregation</strong>을 사용하여 페이징 처리 및 Slice 또는 Page 결과를 반환하는 기능을 제공합니다. 각 메서드는 <strong>Aggregation의 파이프라인</strong>을 동적으로 수정하고, <code>skip</code>과 <code>limit</code>을 추가하여 페이지네이션을 처리합니다.</p>
<h3><span id="applypaginationaggregation-meseodeu">applyPaginationAggregation 메서드</span><a href="#applypaginationaggregation-meseodeu" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S&gt;</span> <span class="title">applyPaginationAggregation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentAggregation: <span class="type">Aggregation</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    countAggregation: <span class="type">Aggregation</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentQuery: (<span class="type">Aggregation</span>) -&gt; <span class="type">AggregationResults</span>&lt;<span class="type">S</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    countQuery: (<span class="type">Aggregation</span>) -&gt; <span class="type">AggregationResults</span>&lt;<span class="type">MongoCount</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: PageImpl&lt;S&gt; = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> skip = pageable.pageNumber * pageable.pageSize</span><br><span class="line">    <span class="keyword">val</span> limit = pageable.pageSize</span><br><span class="line"></span><br><span class="line">    contentAggregation.pipeline.apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.skip(skip.toLong()))</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.limit(limit.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    countAggregation.pipeline.apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.count().`<span class="keyword">as</span>`(<span class="string">&quot;count&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform queries asynchronously</span></span><br><span class="line">    <span class="keyword">val</span> contentDeferred = async(Dispatchers.IO) &#123; contentQuery(contentAggregation) &#125;</span><br><span class="line">    <span class="keyword">val</span> countDeferred = async(Dispatchers.IO) &#123; countQuery(countAggregation) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> content = contentDeferred.await().mappedResults</span><br><span class="line">    <span class="keyword">val</span> totalCount = countDeferred.await().uniqueMappedResult?.count ?: <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">    PageImpl(content, pageable, totalCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="seolmyeong">설명</span><a href="#seolmyeong" class="header-anchor">#</a></h3><ol>
<li><strong><code>contentAggregation</code></strong>:<ul>
<li>페이지네이션을 적용하기 위해 <code>skip</code>과 <code>limit</code>을 <code>contentAggregation</code>에 추가합니다. <code>skip</code>은 현재 페이지의 첫 번째 항목부터 건너뛸 수 있도록 하며, <code>limit</code>은 페이지당 보여줄 항목의 개수를 설정합니다.</li>
</ul>
</li>
<li><strong><code>countAggregation</code></strong>:<ul>
<li>카운트 쿼리를 처리하기 위해 <code>countAggregation</code>에서 <code>$count</code>를 사용하여 총 항목 수를 계산합니다. 이 단계에서는 <code>skip</code>과 <code>limit</code>을 적용하지 않고, 전체 항목 수만 계산합니다.</li>
</ul>
</li>
<li><strong><code>runBlocking</code></strong>:<ul>
<li>비동기 처리를 위해 <code>runBlocking</code>을 사용하여 <code>contentQuery</code>와 <code>countQuery</code>를 동시에 실행합니다. 이렇게 함으로써 <strong>페이징 처리 쿼리</strong>와 <strong>카운트 쿼리</strong>를 병렬로 실행하여 성능을 최적화합니다.</li>
</ul>
</li>
<li><strong>쿼리 실행</strong>:<ul>
<li><strong><code>contentQuery(contentAggregation)</code></strong>: <code>contentAggregation</code>을 기반으로 데이터를 조회합니다.</li>
<li><strong><code>countQuery(countAggregation)</code></strong>: <code>countAggregation</code>을 기반으로 총 개수를 조회합니다.</li>
</ul>
</li>
<li><strong>응답 생성</strong>:<ul>
<li><strong><code>content</code></strong>: 페이징된 결과 목록.</li>
<li><strong><code>totalCount</code></strong>: 전체 항목 수.</li>
<li><code>PageImpl</code> 객체를 생성하여 결과를 반환합니다.</li>
</ul>
</li>
</ol>
<h3><span id="sayongdoen-mongodb-kweori">사용된 MongoDB 쿼리</span><a href="#sayongdoen-mongodb-kweori" class="header-anchor">#</a></h3><h4><span id="peijing-kweori">페이징 쿼리</span><a href="#peijing-kweori" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">db.members.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123;</span><br><span class="line">      &quot;member_id&quot;: &quot;memberId&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$project&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: 1.0,</span><br><span class="line">      &quot;email&quot;: 1.0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$skip&quot;: 0.0</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$limit&quot;: 10.0</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h4><span id="kaunteu-kweori">카운트 쿼리</span><a href="#kaunteu-kweori" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.members.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123;</span><br><span class="line">      &quot;member_id&quot;: &quot;memberId&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$count&quot;: &quot;count&quot;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>이 두 쿼리는 각각 페이징 처리된 결과와 전체 항목 수를 계산하는 쿼리입니다. <code>contentAggregation</code>에서는 <code>skip</code>과 <code>limit</code>을 적용하여 데이터를 제한하고, <code>countAggregation</code>에서는 총 항목 수를 계산합니다.</p>
<h3><span id="applysliceaggregation-meseodeu">applySliceAggregation 메서드</span><a href="#applysliceaggregation-meseodeu" class="header-anchor">#</a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;S&gt;</span> <span class="title">applySliceAggregation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentAggregation: <span class="type">Aggregation</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    contentQuery: (<span class="type">Aggregation</span>) -&gt; <span class="type">AggregationResults</span>&lt;<span class="type">S</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Slice&lt;S&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> skip = pageable.pageNumber * pageable.pageSize</span><br><span class="line">    <span class="keyword">val</span> limit = pageable.pageSize</span><br><span class="line">   contentAggregation.pipeline.apply &#123;</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.skip(skip.toLong()))</span><br><span class="line">        <span class="keyword">this</span>.add(Aggregation.limit(limit.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">val</span> results = contentQuery(contentAggregation)</span><br><span class="line">    <span class="keyword">val</span> content = results.mappedResults</span><br><span class="line">    <span class="keyword">val</span> hasNext = content.size &gt;= pageable.pageSize</span><br><span class="line">    <span class="keyword">return</span> SliceImpl(content, pageable, hasNext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="seolmyeong"><strong>설명</strong>:</span><a href="#seolmyeong" class="header-anchor">#</a></h3><ol>
<li><strong><code>contentAggregation</code></strong>:<ul>
<li><strong><code>contentAggregation</code></strong> 는 사용자가 제공한 Aggregation 객체입니다. 이 객체에는 <code>$match</code>, <code>$project</code>와 같은 데이터 변환 및 필터링 로직이 포함됩니다.</li>
<li><code>contentAggregation</code>에 <strong><code>skip</code></strong> 과 <strong><code>limit</code></strong> 을 추가하여 페이징을 처리합니다. 이를 통해 주어진 <code>pageable</code>에 맞게 데이터를 조회할 수 있습니다.</li>
</ul>
</li>
<li><strong><code>contentQuery</code></strong>:<ul>
<li><code>contentAggregation</code>을 기반으로 데이터를 조회하는 <code>contentQuery</code> 함수입니다. 이 함수는 <code>Aggregation</code>을 받아서 <code>mongoTemplate.aggregate</code>를 사용해 데이터를 가져옵니다.</li>
</ul>
</li>
<li><strong>쿼리 실행</strong>:<ul>
<li><code>contentQuery(contentAggregation)</code>를 실행하여 페이징된 결과를 가져옵니다.</li>
<li><code>skip</code>과 <code>limit</code>을 포함한 <code>contentAggregation</code>을 전달하여 데이터를 필터링합니다.</li>
</ul>
</li>
<li><strong>응답 생성</strong>:<ul>
<li><strong><code>content</code></strong>: 페이징된 결과.</li>
<li><strong><code>hasNext</code></strong>: <code>content</code>의 크기가 <code>pageable.pageSize</code>보다 크거나 같으면, 더 많은 데이터가 있다는 뜻으로 <code>hasNext</code>를 설정합니다.</li>
<li><code>SliceImpl</code> 객체를 생성하여 결과를 반환합니다.</li>
</ul>
</li>
</ol>
<h3><span id="sayongdoen-mongodb-kweori">사용된 MongoDB 쿼리</span><a href="#sayongdoen-mongodb-kweori" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">db.members.aggregate([</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;11-name&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;11-asd@asd.com&quot;,</span><br><span class="line">      &quot;member_id&quot;: &quot;memberId&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$project&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: 1.0,</span><br><span class="line">      &quot;email&quot;: 1.0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$skip&quot;: 0.0</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;$limit&quot;: 10.0</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h3><span id="aggregation-giban-page-mic-slice-johoe-yesi">Aggregation 기반 <code>Page</code> 및 <code>Slice</code> 조회 예시</span><a href="#aggregation-giban-page-mic-slice-johoe-yesi" class="header-anchor">#</a></h3><h4><span id="slice-johoe">Slice 조회</span><a href="#slice-johoe" class="header-anchor">#</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findSliceAggregation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    email: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    memberId: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Slice&lt;MemberProjection&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> match = Aggregation.match(</span><br><span class="line">        Criteria().apply &#123;</span><br><span class="line">            name?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            email?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;email&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            memberId?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;member_id&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> projection = Aggregation.project()</span><br><span class="line">        .andInclude(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        .andInclude(<span class="string">&quot;email&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.applySliceAggregation(</span><br><span class="line">        pageable = pageable,</span><br><span class="line">       contentAggregation = Aggregation.newAggregation(match, projection),</span><br><span class="line">        contentQuery = &#123; mongoTemplate.aggregate(it, Member.DOCUMENT_NAME, MemberProjection::<span class="keyword">class</span>.java) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="page-johoe">Page 조회</span><a href="#page-johoe" class="header-anchor">#</a></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">findPageAggregation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    pageable: <span class="type">Pageable</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    email: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    memberId: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Page&lt;MemberProjection&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> match = Aggregation.match(</span><br><span class="line">        Criteria().apply &#123;</span><br><span class="line">            name?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;name&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            email?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;email&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">            memberId?.let &#123; <span class="keyword">this</span>.and(<span class="string">&quot;member_id&quot;</span>).`<span class="keyword">is</span>`(it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> projection = Aggregation.project()</span><br><span class="line">        .andInclude(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        .andInclude(<span class="string">&quot;email&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> applyPaginationAggregation(</span><br><span class="line">        pageable = pageable,</span><br><span class="line">        contentAggregation = Aggregation.newAggregation(match, projection),</span><br><span class="line">        countAggregation = Aggregation.newAggregation(match),</span><br><span class="line">        contentQuery = &#123; mongoTemplate.aggregate(it, Member.DOCUMENT_NAME, MemberProjection::<span class="keyword">class</span>.java) &#125;,</span><br><span class="line">        countQuery = &#123; mongoTemplate.aggregate(it, Member.DOCUMENT_NAME, MongoCount::<span class="keyword">class</span>.java) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="gyeolron"><strong>결론</strong></span><a href="#gyeolron" class="header-anchor">#</a></h2><ul>
<li>기존 <code>Query</code> 기반 페이징에서 <code>T</code> 타입 한계를 벗어나 <strong>Projection을 지원</strong>하도록 확장</li>
<li><strong><code>Aggregation</code>을 활용한 페이징 처리</strong>로 다양한 데이터 변환 및 성능 최적화 가능</li>
<li><strong>비동기(<code>async</code>) 처리로 성능 최적화</strong>하며, 코드 재사용성을 높임</li>
</ul>
<p>이제 Spring Data MongoDB에서 <strong>확장 가능한 Projection 기반 Pagination을 활용한 Repository를 구축</strong>할 수 있습니다.</p>

            


        </div>
    </div>
    <!-- Table of Contents -->
    <div id="toc-container">
        <div class="toc-title">목차</div>
        <ul id="toc-list"></ul>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">태그</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Mongo/" rel="tag">Mongo</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongodb-update-arrayFilters/"
                    data-tooltip="Spring Data MongoDB로 배열의 특정 요소 업데이트하기"
                    aria-label="이전: Spring Data MongoDB로 배열의 특정 요소 업데이트하기"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongo-update-guide-1/"
                    data-tooltip="Spring Data MongoDB에서의 Update 전략과 경험"
                    aria-label="다음: Spring Data MongoDB에서의 Update 전략과 경험"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-data-mongo-repository-2/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-data-mongo-repository-2/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        

                
                    <!--  giscus comment -->

<script src="https://giscus.app/client.js"
        data-repo="cheese10yun/blog-comment"
        data-repo-id="MDEwOlJlcG9zaXRvcnkyMDU1MDM1OTk="
        data-category="Q&amp;A"
        data-category-id="DIC_kwDODD-8b84CT2XX"
        data-mapping="og:title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="1"
        data-input-position="top"
        data-theme="light"
        data-lang=""
        crossorigin="anonymous"
        async>
</script>


                

            
        
    </div>
</article>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2026 Yun. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongodb-update-arrayFilters/"
                    data-tooltip="Spring Data MongoDB로 배열의 특정 요소 업데이트하기"
                    aria-label="이전: Spring Data MongoDB로 배열의 특정 요소 업데이트하기"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">이전</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/spring-data-mongo-update-guide-1/"
                    data-tooltip="Spring Data MongoDB에서의 Update 전략과 경험"
                    aria-label="다음: Spring Data MongoDB에서의 Update 전략과 경험"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">다음</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="이 포스트 공유하기"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-data-mongo-repository-2/"
                    title="Facebook에 공유하기"
                    aria-label="Facebook에 공유하기"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-data-mongo-repository-2/"
                    title="Twitter에 공유하기"
                    aria-label="Twitter에 공유하기"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="맨 위로">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="5">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://cheese10yun.github.io/spring-data-mongo-repository-2/"
                        aria-label="Facebook에 공유하기"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Facebook에 공유하기</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://cheese10yun.github.io/spring-data-mongo-repository-2/"
                        aria-label="Twitter에 공유하기"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Twitter에 공유하기</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/yun-icon.jpg" alt="저자 이미지"/>
        
            <h4 id="about-card-name">Yun</h4>
        
            <div id="about-card-bio"><p>기술 블로그</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/jquery.js"></script>


<script src="/assets/js/jquery.fancybox.js"></script>


<script src="/assets/js/thumbs.js"></script>


<script src="/assets/js/tranquilpeak.js"></script>



<script src="/assets/js/toc.js"></script>


<!--SCRIPTS END-->


    




    </body>
</html>
